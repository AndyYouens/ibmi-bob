#!/usr/bin/bash

# Scan through current directory of BLDOPT files and extract commands and parameters.
#
# To invoke:
# o cd source_directory
# o path/to/exportbldopts output_file
#
# Processing
# o Read through each ADM BLDOPT file
# o Remove comments
# o Reformat build commands to take up one line each
# o For each object and command type, remove all compile parameters that are duplicates of our defaults for that object and type.
# o If any non-default compile parameters remain, output them one at a time to the output file, like "SO1001.PGM: private TGTRLS = $target_release"
# o Output object dependencies based on 'SRCMBR', 'MODULE' and 'BNDSRVPGM' parameters, like "SEGDES.1.PGM: SEGDES.1.MODULE SEGDEF_S.SRVPGM SEGACT_S.SRVPGM"
#   Don't forget binder source, too.
#
# Notes:
# o All source must be in the same directory (including bldopt files (ending in .BLDOPT) and binder source (ending in .BND).

# Global default values
DFT_AUT='AUT(\*EXCLUDE)'
DFT_TGTRLS='TGTRLS([^)]*)'
DFT_USRPRF='USRPRF(\*USER)'

# Default values for each object type
CLMOD_DFT=( 'OPTION(\*EVENTF)' )
CMD_DFT=( 'VLDCKR(\*NONE)' 'PMTFILE(\*NONE)' )
CMOD_DFT=( 'TERASPACE(\*YES \*NOTSIFC)' 'STGMDL(\*INHERIT)' 'SYSIFCOPT(\*IFSIO)' 'OPTION(\*SYSINCPATH \*EVENTF \*SHOWUSR \*XREF \*AGR \*STRUCREF)' )
DSPF_DFT=( 'RSTDSP(\*YES)' )
PNLGRP_DFT=( 'OPTION(\*EVENTF)' )
RPGMOD_DFT=()
SQLCI_DFT=( 'COMMIT(\*NONE)' )
SQLRPGI_DFT=( 'COMMIT(\*NONE)' )
BNDCL_DFT=( 'DFTACTGRP(\*NO)' 'ACTGRP(E_PRODUCT)' )
SRVPGM_DFT=( 'ACTGRP(\*CALLER)' 'STGMDL(\*SNGLVL)' 'BNDDIR(\*NONE)' )
PGM_DFT=( 'ACTGRP(E_PRODUCT)' )

sourceDeps=
objectDeps=
metadataDir=".exportbldopts"
outputFile=$1


trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}

# Adds a suffix to each item in the parameter.
# $1 = a variable containing a list of items
# $2 = the suffix to add to each item
# Returns: the new list of items to stdout.
add_suffix() {
	local items=$1
	local suffix=$2
	local output=
	
	for item in $items; do
		output="$output ${item}.$suffix"
	done
	
	output=${output# }
	echo -n $output
}

# Returns the IFS suffix appropriate for a given compile command's output object. e.g., $(suffix_for_command "CRTRPGMOD") -> "MODULE"
# $1 = the standard i compile command for a given object
# Returns: the filename suffix the object would have when viewed through the IFS (.MODULE, .FILE, etc.)
obj_suffix_for_cmd() {
	local command=$1
	local suffix=
	
	case "$command" in
		CRTBNDCL)	suffix="PGM";;
		CRTCLMOD)	suffix="MODULE";;
		CRTCMD)		suffix="CMD";;
		CRTCMOD)	suffix="MODULE";;
		CRTDSPF)	suffix="FILE";;
		CRTLF)		suffix="FILE";;
		CRTPF)		suffix="FILE";;
		CRTPNLGRP)	suffix="PNLGRP";;
		CRTPRTF)	suffix="FILE";;
		CRTPGM)		suffix="PGM";;
		CRTRPGMOD)	suffix="MODULE";;
		CRTSQLCI | CRTSQLRPGI)
			if [[ "${parms}" =~ OBJTYPE\(([^\)]*)\) ]]; then
				case "${BASH_REMATCH[1]}" in
					\*MODULE)	suffix="MODULE";;
					\*PGM)		suffix="PGM";;
					\*SRVPGM)	suffix="SRVPGM";;
					*)			suffix="UNKNOWN";;
				esac
			else
				suffix="UNKNOWN"
			fi
			;;
		CRTSRVPGM)	suffix="SRVPGM";;
		*)			suffix="UNKNOWN"
					echo "*** Unknown command type in obj_suffix_for_cmd: $command" >&2
					;;
	esac

	echo -n "$suffix"
}

# Returns the IFS suffix appropriate for a given compile command's source file. e.g., $(suffix_for_command "CRTRPGMOD") -> ".RPGLE"
# $1 = the standard i compile command for a given object
# Returns: the filename suffix the source file would have when viewed through the IFS (.RPGLE, .PF, etc.)
src_suffix_for_cmd() {
	local command=$1
	local suffix=
	
	case "$command" in
		CRTBNDCL)	suffix="CLLE";;
		CRTCLMOD)	suffix="CLLE";;
		CRTCMD)		suffix="CMD";;
		CRTCMOD)	suffix="C";;
		CRTDSPF)	suffix="DSPF";;
		CRTLF)		suffix="LF";;
		CRTPF)		suffix="PF";;
		CRTPNLGRP)	suffix="PNLGRP";;
		CRTPGM)		;;
		CRTPRTF)	suffix="PRTF";;
		CRTRPGMOD)	suffix="RPGLE";;
		CRTSQLCI)	suffix="SQLC";;
		CRTSQLRPGI)	suffix="SQLRPGLE";;
		CRTSRVPGM)	suffix="BND";;
		*)			echo "*** Unknown command type in src_suffix_for_cmd: $command" >&2;;
	esac

	echo -n "$suffix"
}

# The `process_parms` function removes any compile parameters that match our defaults for that object type and
# then outputs the remainder to stdout.
# $1 = object name
# $2 = compile parameters
# $3 = an array containing all our default parameters for that object type
process_parms() {
	local object=$1
	shift
	local parms=$1
	shift
	local defaults=("$@")
	
#	parmsSave=$parms
	parms=" $parms "

	for parm in "${defaults[@]}"; do
#		echo "parms=$parms" >&2
#		echo "parm =$parm" >&2
		parms=${parms/ $parm / }
	done
	
	parms=$(trim $parms)
	
#	echo $object >&2
#	echo "**Original parms: $object: $parmsSave" >&2
#	echo "**     New parms: $object: $parms" >&2

	echo -n "$parms"
}

cleanup_cmd_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If CMD() value equals the object name, remove the parameter.
	parms=${parms/ CMD($object) / }
	
	# If PGM() value equals the object name, remove the parameter.
	parms=${parms/ PGM($object) / }
	
	# If HLPPNLGRP() value equals the object name, remove the parameter.
	parms=${parms/ HLPPNLGRP($object) / }
	
	# If HLPID() value equals the object name, remove the parameter.
	parms=${parms/ HLPID($object) / }

	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_dspf_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If FILE() value equals the object name, remove the parameter.
	parms=${parms/ FILE($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_module_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If MODULE() value equals the object name, remove the parameter.
	parms=${parms/ MODULE($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_pnlgrp_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If PNLGRP() value equals the object name, remove the parameter.
	parms=${parms/ PNLGRP($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_prtf_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If FILE() value equals the object name, remove the parameter.
	parms=${parms/ FILE($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_sqli_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If OBJ() value equals the object name, remove the parameter.
	parms=${parms/ OBJ($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_pgm_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If PGM() value equals the object name, remove the parameter.
	parms=${parms/ PGM($object) / }
	
	# Remove MODULE() and BNDSRVPGM() parameters, as they've already been harvested in get_object_deps().
	if [[ "$parms" =~ (MODULE\([^\)]*\)) ]]; then
		parms=${parms/ ${BASH_REMATCH[1]} / }
	fi
	if [[ "$parms" =~ (BNDSRVPGM\([^\)]*\)) ]]; then
		parms=${parms/ ${BASH_REMATCH[1]} / }
	fi
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_srvpgm_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If SRVPGM() value equals the object name, remove the parameter.
	parms=${parms/ SRVPGM($object) / }
	
	# Remove MODULE() and BNDSRVPGM() parameters, as they've already been harvested in get_object_deps().
	if [[ "$parms" =~ (MODULE\([^\)]*\)) ]]; then
		parms=${parms/ ${BASH_REMATCH[1]} / }
	fi
	if [[ "$parms" =~ (BNDSRVPGM\([^\)]*\)) ]]; then
		parms=${parms/ ${BASH_REMATCH[1]} / }
	fi
	
	parms=$(trim $parms)
	echo -n "$parms"
}

# Gather object dependencies by extracting them from compile parameters
get_object_deps() {
	local object=$1
	local command=$2
	local parms=$3
	local deps=
	local output=
	
	case "$command" in
		CRTBNDCL)
			# BNDCL doesn't have any object dependencies.
			;;
		CRTCLMOD)
			# CLMOD doesn't have any object dependencies.
			;;
		CRTCMD)
			# No object dependencies? If a CPP changes, we don't want to recompile the command object.
			;;
		CRTCMOD)
			# Is there any way to get a definitive list of files used in C?
			;;
		CRTDSPF)
			# Scan through source and look for REF() and add those items as object dependencies. Any other keywords?
			if [[ -f ${object}.DSPF ]]; then
				deps=$(sed -n -e 's/.*REF(\([^)]*\).*/\1/p' -e '/\// s/.*\///p')
				output=$(add_suffix "$deps" FILE)
			fi
			;;
		CRTLF)
			# PFILE or JFILE values
			if [[ -f ${object}.LF ]]; then
				deps=$(sed -n -e 's/.*PFILE(\([^)]*\).*/\1/p' -e 's/.*JFILE(\([^)]*\).*/\1/p' ${object}.LF | xargs -n 1 | sort -u | xargs)
				output=$(add_suffix "$deps" FILE)
			fi
			;;
		CRTPNLGRP)
			# No object dependencies on panel groups
			;;
		CRTPRTF)
			# No object dependencies on printer file.
			;;
		CRTRPGMOD)
			# Call script to parse F-specs for files and data areas
			;;
		CRTSQLCI)			
			# Is there any way to extract files out of SQLC code?
			;;
		CRTSQLRPGI)			
			# Call script to parse F-specs for files and data areas. And files accessed by SQL?
			;;
		CRTPGM)			
			# Modules bound into the program
			if [[ $parms =~ MODULE\(([^\)]*)\) ]]; then
				deps="${BASH_REMATCH[1]}"
				output=$(add_suffix "$deps" MODULE)
			fi
			# Service programs linked to this program.
			if [[ $parms =~ BNDSRVPGM\(([^\)]*)\) ]]; then
				deps="${BASH_REMATCH[1]}"
				deps=$(add_suffix "$deps" SRVPGM)
				output="$output $deps"
			fi
			;;
		CRTSRVPGM)
			# Modules bound into the service program
			if [[ $parms =~ MODULE\(([^\)]*)\) ]]; then
				deps="${BASH_REMATCH[1]}"
				output=$(add_suffix "$deps" MODULE)
			fi
			# Other service programs linked to this service program.
			if [[ $parms =~ BNDSRVPGM\(([^\)]*)\) ]]; then
				deps="${BASH_REMATCH[1]}"
				deps=$(add_suffix "$deps" SRVPGM)
				output="$output $deps"
			fi
			;;
		*)	echo "*** Unknown command $command found for object $object in get_object_deps" >&2
			;;
		esac
		
		echo -n "$(trim $output)"
}

# Gather source dependencies by extracting them from compile parameters
# Note: Header or include files are gathered at compile time, so don't include those here.
get_source_deps() {
	local object=$1
	local command=$2
	local parms=$3
	local deps=
	local output=
	
	case "$command" in
		CRTCLMOD|CRTCMD|CRTCMOD|CRTDSPF|CRTPNLGRP|CRTRPGMOD|CRTSQLCI|CRTSQLRPGI|CRTBNDCL|CRTPF|CRTLF|CRTPRTF)
			if [[ $parms =~ SRCMBR\(([^\)]*)\) ]]; then
				deps=${BASH_REMATCH[1]}
			else
				deps=$object
			fi
			;;
		CRTSRVPGM)
			if [[ -f ${object}.BND ]]; then
				deps=${object}
			fi
			;;
		CRTPGM)
			# No source dependencies for programs.
			;;
		*)
			echo "*** Unknown command $command found for object $object in get_source_deps" >&2
			;;
	esac
	
	local suffix=$(src_suffix_for_cmd "$command")
	output=$(add_suffix "$deps" $suffix)
	
	echo -n "$output"
}

# Prints out to stdout compile parameters in makefile variable format for one object (e.g., TGTRLS = V7R1M0)
# $1 = object name, including suffix ("JSB100.PGM")
# $2 = compile parameters
print_parms() {
	local fullObject=$1
	local parms=$2
	re='^([^\)]*\))'
	
	while [[ "${parms}" =~ ${re} ]]; do
		parm="${BASH_REMATCH[1]}"
		parms=${parms:${#BASH_REMATCH[1]}}
		parms=${parms# }
		#echo "parm: |$parm|"
		
		# Split apart 'ABC(XYZ)' into 'ABC' and 'XYZ'
		if [[ $parm =~ ^([^\(]*)\(([^\)]*)\) ]]; then
			echo "$fullObject: private ${BASH_REMATCH[1]} = ${BASH_REMATCH[2]}"
		fi
	done
	
	# Write object to the metadata log file for this object type, as a record of this object existing.
	echo "${fullObject}" >> "$metadataDir/${fullObject##*.}.log"
}

# Prints a summary report (redirected to stderr)
print_summary() {
	(( totalCount = 0 ))
	echo; echo
	echo "*** EXPORT COMPLETE! ***"
	echo
	echo "Objects exported:"
	echo
	
	for logFile in $metadataDir/*.log; do
		(( count=$(wc -l <$logFile) ))
		(( totalCount += count ))
		printf "\t$(basename ${logFile%.*}):\t%u\n" $count
	done
	
	echo
	echo "Total objects exported: $totalCount"
	echo "Output file: ${metadataDir}/$outputFile"
}

# Main processing for the contents of a .BLDOPT file.
#
# Assume that bldopt filename is the same name as all &ZN and &ZE substitution variables.  If this turns out to not
# be the case, remove the sed -e below that inserts $base: at the beginning of the line, and add a function that determines
# object name for each object type based on its object parameter (CMD() for commands, MODULE() for modules, etc.).
process_bldopt() {
	base=$(basename $file .BLDOPT)

	sed -e 's/\/\*.*\*\///g' -e 's/ *$//' -e :a -e '/+ *$/N; s/ *+ *\n */ /; ta' -e 's/\/\*.*\*\///g' -e 's/^ *//' -e '/^$/d' -e 's/ *) */) /g' -e 's/^/'$base': /' \
        -e 's/&O\/\|&L\///g' -e 's/&ZE\|&ZN/'$base'/g' -e 's/SRCMBR('$base') *//I' -e 's/\*LIBL\///I g' -e 's/ SRCFILE([^)]*) */ /I' \
		-e 's/(  */(/g' -e 's/  *)/)/g' \
		-e 's/REPLACE(\*YES) *//I' -e 's/DBGVIEW([^)]*) *//I' -e 's/OUTPUT(\*PRINT) *//I' -e 's/DETAIL([^)]*) *//I' \
		-e 's/'$DFT_AUT' *//I' -e 's/'$DFT_TGTRLS' *//I' -e 's/'$DFT_USRPRF' *//I' \
		-e 's/\(OPTION([^)]*\)\*GEN *\([^)]*)\)/\1\2/I' -e 's/ *[^ ]\+( *)//Ig' \
	$file | \
	{
		while IFS='' read -r line || [[ -n "$line" ]]; do
			object=$(trim ${line/:*/})
			temp=$(trim ${line/${object}:/})
			command=$(trim ${temp/ */})
			parms=$(trim ${temp/$command/})
			fullObject="$object.$(obj_suffix_for_cmd $command)"
			
			# Remove parameters that match our defaults.
			case "$command" in
			CRTBNDCL)	parms=$(process_parms $object "$parms" "${BNDCL_DFT[@]}")
						;;
			CRTCLMOD)	parms=$(process_parms $object "$parms" "${CLMOD_DFT[@]}")
						;;
			CRTCMD)		parms=$(process_parms $object "$parms" "${CMD_DFT[@]}")
						;;
			CRTCMOD)	parms=$(process_parms $object "$parms" "${CMOD_DFT[@]}")
						;;
			CRTDSPF)	parms=$(process_parms $object "$parms" "${DSPF_DFT[@]}")
						;;
			CRTPGM)		parms=$(process_parms $object "$parms" "${PGM_DFT[@]}")
						;;
			CRTPNLGRP)	parms=$(process_parms $object "$parms" "${PNLGRP_DFT[@]}")
						;;
			CRTPRTF)	;; # Nothing to do
			CRTRPGMOD)	parms=$(process_parms $object "$parms" "${RPGMOD_DFT[@]}")
						;;
			CRTSQLCI)	parms=$(process_parms $object "$parms" "${SQLCI_DFT[@]}")
						;;
			CRTSQLRPGI)	parms=$(process_parms $object "$parms" "${SQLRPGI_DFT[@]}")
						;;
			CRTSRVPGM)	parms=$(process_parms $object "$parms" "${SRVPGM_DFT[@]}")
						;;
			*)			echo "*** Unknown command $command found for object $object"
						;;
			esac
			
#		echo "$object: $command $parms"
			
			# Gather object dependencies by extracting from various parameters
			objectDeps=$(get_object_deps $object $command "$parms")
					
			# Extra clean-up
			case "$command" in
			CRTCMD)		parms=$(cleanup_cmd_parms $object "$parms")
						;;
			CRTCMOD	| CRTRPGMOD | CRTCLMOD) 
						parms=$(cleanup_module_parms $object "$parms")
						;;
			CRTDSPF)	parms=$(cleanup_dspf_parms $object "$parms")
						;;
			CRTPNLGRP)	parms=$(cleanup_pnlgrp_parms $object "$parms")
						;;
			CRTPRTF)	parms=$(cleanup_prtf_parms $object "$parms")
						;;
			CRTSQLRPGI | CRTSQLCI)
						parms=$(cleanup_sqli_parms $object "$parms")
						;;
			CRTBNDRPG | CRTBNDCL | CRTPGM)
						parms=$(cleanup_pgm_parms $object "$parms")
						;;
			CRTSRVPGM)	parms=$(cleanup_srvpgm_parms $object "$parms")
						;;
			esac
			
			
			# Get source dependencies for source-based objects (srvpgms can use binder source) (also peer inside RPGs?)
			sourceDeps=$(get_source_deps $object $command "$parms")
			
			# Blank line before each object's entries
			echo
			
			# For debugging
#			echo "read line: ${line}"
			
			# Add a comment showing object metadata for debug purposes
			echo "# $fullObject -- $command"
			
			## Output custom compile parameters in makefile format
			print_parms $fullObject "$parms"
			
			# Write object: sourcedeps objectdeps		
			output="$fullObject: $sourceDeps"
			output="${output% } $objectDeps"
			
#			if [[ ${#output} -ge 110 ]]; then
#				echo "$output" | fold -s -w 100 | sed -e '$ ! s/$/\\/'
#			else
				echo "$output"
#			fi
		done
	}
}

############################
# Beginning of main script #
############################

# Clear/create metadata subdirectory for logging imported objects.
if [ ! -d "$metadataDir" ]; then
	mkdir "$metadataDir"
fi
[ "$(ls -A $metadataDir)" ] && rm -r $metadataDir/*
echo "This directory contains info about the items in the parent directory." > "$metadataDir/Readme.txt"

files=( "*.*" )
# echo ${files[@]}
for file in $files; do
	fileSuffix=${file##*.}

	if [[ $fileSuffix == "BLDOPT" ]]; then
		process_bldopt >> $metadataDir/$outputFile
	fi
	
done

print_summary >&2
