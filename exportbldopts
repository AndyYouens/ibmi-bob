#!/usr/bin/bash

# Scan through current directory of BLDOPT files and extract commands and parameters.
#
# Processing
# o Read through each ADM BLDOPT file
# o Remove comments
# o Reformat build commands to take up one line each
# o For each object and command type, remove all compile parameters that are duplicates of our defaults for that object and type.
# o If any non-default compile parameters remain, output them one at a time to the output file, like "SO1001.PGM: private TGTRLS = $target_release"
# o Output object dependencies based on 'SRCMBR', 'MODULE' and 'BNDSRVPGM' parameters, like "SEGDES.1.PGM: SEGDES.1.MODULE SEGDEF_S.SRVPGM SEGACT_S.SRVPGM"
#   Don't forget binder source, too.

# Global default values
DFT_AUT='AUT(\*EXCLUDE)'
DFT_TGTRLS='TGTRLS(V5R1M0)'
DFT_USRPRF='USRPRF(\*USER)'

# Default values for each object type
CMD_DFT=( 'VLDCKR(\*NONE)' 'PMTFILE(\*NONE)' )
CMOD_DFT=( 'TERASPACE(\*YES \*NOTSIFC)' 'STGMDL(\*INHERIT)' 'SYSIFCOPT(\*IFSIO)' 'OPTION(\*SYSINCPATH \*EVENTF \*SHOWUSR \*XREF \*AGR \*STRUCREF)' )
RPGMOD_DFT=()
SQLRPGI_DFT=( 'COMMIT(\*NONE)' )
BNDCL_DFT=( 'DFTACTGRP(\*NO)' 'ACTGRP(E_PRODUCT)' )
SRVPGM_DFT=( 'ACTGRP(\*CALLER)' 'STGMDL(\*SNGLVL)' )
PGM_DFT=( 'ACTGRP(E_PRODUCT)' )




trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}

# The `process_parms` function removes any compile parameters that match our defaults for that object type and
# then outputs the remainder to stdout.
# $1 = object name
# $2 = compile parameters
# $3 = an array containing all our default parameters for that object type
process_parms() {
	local object=$1
	shift
	local parms=$1
	shift
	local defaults=("$@")
	
#	parmsSave=$parms
	parms=" $parms "

	for parm in "${defaults[@]}"
	do
#		echo "parms=$parms" >&2
#		echo "parm =$parm" >&2
		parms=${parms/ $parm / }
	done
	
	parms=$(trim $parms)
	
#	echo $object >&2
#	echo "**Original parms: $object: $parmsSave" >&2
#	echo "**     New parms: $object: $parms" >&2

	echo -n "$parms"
}

cleanup_cmd_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If CMD() value equals the object name, remove the parameter.
	parms=${parms/ CMD($object) / }
	
	# If PGM() value equals the object name, remove the parameter.
	parms=${parms/ PGM($object) / }

	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_module_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If MODULE() value equals the object name, remove the parameter.
	parms=${parms/ MODULE($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_module_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If MODULE() value equals the object name, remove the parameter.
	parms=${parms/ MODULE($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_sqli_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If OBJ() value equals the object name, remove the parameter.
	parms=${parms/ OBJ($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_pgm_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If PGM() value equals the object name, remove the parameter.
	parms=${parms/ PGM($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_srvpgm_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If SRVPGM() value equals the object name, remove the parameter.
	parms=${parms/ SRVPGM($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

# Gather object dependencies by extracting them from compile parameters
get_object_deps() {
	local object=$1
	local command=$2
	local parms=$3
	local deps=
	
	case "$command" in
		CRTCMD)
			if [[ $parms =~ CMD\(([^\)]*)\) ]]; then
				deps=${BASH_REMATCH[1]}
			else
				deps=$object
			fi
			;;
		CRTCMOD)
			
			;;
		CRTRPGMOD)	
					;;
		CRTSQLRPGI)	
					;;
		CRTBNDCL)	
					;;
		CRTSRVPGM)	
					;;
		CRTPGM)		
					;;
		*)			echo "*** Unknown command $command found for object $object"
					;;
		esac
}


#echo "SQLRPGI_DFT=${#SQLRPGI_DFT}"
files=( "*" )
for file in $files; do
	base=$(basename $file .CLP)
	sed -e 's/\/\*.*\*\///g' -e 's/ *$//' -e :a -e '/+ *$/N; s/ *+ *\n */ /; ta' -e '/^$/d' -e 's/^ *//' -e 's/ *) */) /g' -e 's/^/'$base': /' \
        -e 's/&O\///' -e 's/\&ZE/'$base'/g' -e 's/SRCMBR(&[^)]*) *//I' -e 's/SRCFILE(&[^)]*) *//I' -e 's/\*LIBL\///I g' \
		-e 's/REPLACE(\*YES) *//I' -e 's/DBGVIEW([^)]*) *//I' -e 's/OUTPUT(\*PRINT) *//I' -e 's/DETAIL([^)]*) *//I' \
		-e 's/'$DFT_AUT' *//I' -e 's/'$DFT_TGTRLS' *//I' -e 's/'$DFT_USRPRF' *//I' \
	$file | \
	sed -e 's/ *\/\*.*\*\/ *//g' | \
	{
	while IFS='' read -r line || [[ -n "$line" ]]; do
		object=$(trim ${line/:*/})
		temp=$(trim ${line/${object}:/})
		command=$(trim ${temp/ */})
		parms=$(trim ${temp/$command/})

		# Remove parameters that match our defaults.
		case "$command" in
		CRTCMD)		parms=$(process_parms $object "$parms" "${CMD_DFT[@]}")
					;;
		CRTCMOD)	parms=$(process_parms $object "$parms" "${CMOD_DFT[@]}")
					;;
		CRTRPGMOD)	parms=$(process_parms $object "$parms" "${RPGMOD_DFT[@]}")
					;;
		CRTSQLRPGI)	parms=$(process_parms $object "$parms" "${SQLRPGI_DFT[@]}")
					;;
		CRTBNDCL)	parms=$(process_parms $object "$parms" "${BNDCL_DFT[@]}")
					;;
		CRTSRVPGM)	parms=$(process_parms $object "$parms" "${SRVPGM_DFT[@]}")
					;;
		CRTPGM)		parms=$(process_parms $object "$parms" "${PGM_DFT[@]}")
					;;
		*)			echo "*** Unknown command $command found for object $object"
					;;
		esac
		
		echo "$object: $command $parms"
		
		# Gather object dependencies by extracting from various parameters
		objectDeps=$(get_object_deps $object $command "$parms")
				
		# Extra clean-up
		case "$command" in
		CRTCMD)		parms=$(cleanup_cmd_parms $object "$parms")
					;;
		CRTCMOD	| CRTRPGMOD | CRTCLMOD) 
					parms=$(cleanup_module_parms $object "$parms")
					;;
		CRTSQLRPGI | CRTSQLCI)
					parms=$(cleanup_sqli_parms $object "$parms")
					;;
		CRTBNDRPG | CRTBNDCL | CRTPGM)
					parms=$(cleanup_pgm_parms $object "$parms")
					;;
		CRTSRVPGM)	parms=$(cleanup_srvpgm_parms $object "$parms")
					;;
		esac
		
		
		# Get source dependencies for source-based objects (srvpgms can use binder source) (also peer inside RPGs?)
		
		## Output in makefile format
		# Write object: variable = parameter (or :=?)
		# Write object: sourcedep objectdeps
		
#		if [[ -z ${parms// } ]] # tests for empty string
	done
	}
done