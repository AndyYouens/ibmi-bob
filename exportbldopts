#!/usr/bin/bash

# Scan through current directory of BLDOPT files and extract commands and parameters.
#
# To invoke:
# o cd source_directory
# o path/to/exportbldopts output_file
#
# Processing
# o Read through each ADM BLDOPT file
# o Remove comments
# o Reformat build commands to take up one line each
# o For each object and command type, remove all compile parameters that are duplicates of our defaults for that object and type.
# o If any non-default compile parameters remain, output them one at a time to the output file, like "SO1001.PGM: private TGTRLS = $target_release"
# o Output object dependencies based on 'SRCMBR', 'MODULE' and 'BNDSRVPGM' parameters, like "SEGDES.1.PGM: SEGDES.1.MODULE SEGDEF_S.SRVPGM SEGACT_S.SRVPGM"
#   Don't forget binder source, too.
#
# Notes:
# o All source must be in the same directory (including bldopt files (ending in .BLDOPT) and binder source (ending in .BND).

# Global default values
DFT_AUT='AUT(\*EXCLUDE)'
DFT_TGTRLS='TGTRLS([^)]*)'
DFT_USRPRF='USRPRF(\*USER)'

# Default values for each object type
CLMOD_DFT=( 'OPTION(\*EVENTF)' )
CMD_DFT=( 'VLDCKR(\*NONE)' 'PMTFILE(\*NONE)' )
CMOD_DFT=( 'TERASPACE(\*YES \*NOTSIFC)' 'STGMDL(\*INHERIT)' 'SYSIFCOPT(\*IFSIO)' 'OPTION(\*SYSINCPATH \*EVENTF \*SHOWUSR \*XREF \*AGR \*STRUCREF)' )
DSPF_DFT=( 'RSTDSP(\*YES)' )
MENU_DFT=()
PNLGRP_DFT=( 'OPTION(\*EVENTF)' )
RPGMOD_DFT=()
SQLCI_DFT=( 'COMMIT(\*NONE)' )
SQLRPGI_DFT=( 'COMMIT(\*NONE)' )
BNDCL_DFT=( 'DFTACTGRP(\*NO)' 'ACTGRP(E_PRODUCT)' )
SRVPGM_DFT=( 'ACTGRP(\*CALLER)' 'STGMDL(\*SNGLVL)' 'BNDDIR(\*NONE)' )
PGM_DFT=( 'ACTGRP(E_PRODUCT)' )

sourceDeps=
objectDeps=
metadataDir=".exportbldopts"
outputFile=$1


trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}

# Adds a suffix to each item in the parameter.
# $1 = a variable containing a list of items
# $2 = the suffix to add to each item
# Returns: the new list of items to stdout.
add_suffix() {
	local items=$1
	local suffix=$2
	local output=
	
	for item in $items; do
		output="$output ${item}.$suffix"
	done
	
	output=${output# }
	echo -n $output
}

# Returns the IFS suffix appropriate for a given compile command's output object. e.g., $(suffix_for_command "CRTRPGMOD") -> "MODULE"
# $1 = the standard i compile command for a given object
# Returns: the filename suffix the object would have when viewed through the IFS (.MODULE, .FILE, etc.)
obj_suffix_for_cmd() {
	local command=$1
	local suffix=
	
	case "$command" in
		CRTBNDC)	suffix="PGM";;
		CRTBNDCL)	suffix="PGM";;
		CRTBNDRPG)	suffix="PGM";;
		CRTCLMOD)	suffix="MODULE";;
		CRTCMD)		suffix="CMD";;
		CRTCMOD)	suffix="MODULE";;
		CRTDSPF)	suffix="FILE";;
		CRTLF)		suffix="FILE";;
		CRTMNU)		suffix="MENU";;
		CRTPF)		suffix="FILE";;
		CRTPNLGRP)	suffix="PNLGRP";;
		CRTPRTF)	suffix="FILE";;
		CRTPGM)		suffix="PGM";;
		CRTRPGMOD)	suffix="MODULE";;
		CRTSQLCI | CRTSQLRPGI)
			if [[ "${parms}" =~ OBJTYPE\(([^\)]*)\) ]]; then
				case "${BASH_REMATCH[1]}" in
					\*MODULE)	suffix="MODULE";;
					\*PGM)		suffix="PGM";;
					\*SRVPGM)	suffix="SRVPGM";;
					*)			suffix="UNKNOWN";;
				esac
			else
				suffix="UNKNOWN"
			fi
			;;
		CRTSRVPGM)	suffix="SRVPGM";;
		*)			suffix="UNKNOWN"
					echo "*** Unknown command type in obj_suffix_for_cmd: $command" >&2
					;;
	esac

	echo -n "$suffix"
}

# Returns the IFS suffix appropriate for a given compile command's source file. e.g., $(suffix_for_command "CRTRPGMOD") -> ".RPGLE"
# $1 = the standard i compile command for a given object
# Returns: the filename suffix the source file would have when viewed through the IFS (.RPGLE, .PF, etc.)
src_suffix_for_cmd() {
	local command=$1
	local suffix=
	
	case "$command" in
		CRTBNDC)	suffix="C";;
		CRTBNDCL)	suffix="CLLE";;
		CRTBNDRPG)	suffix="RPGLE";;
		CRTCLMOD)	suffix="CLLE";;
		CRTCMD)		suffix="CMD";;
		CRTCMOD)	suffix="C";;
		CRTDSPF)	suffix="DSPF";;
		CRTLF)		suffix="LF";;
		CRTMNU)		suffix="MENU";;
		CRTPF)		suffix="PF";;
		CRTPNLGRP)	suffix="PNLGRP";;
		CRTPGM)		;;
		CRTPRTF)	suffix="PRTF";;
		CRTRPGMOD)	suffix="RPGLE";;
		CRTSQLCI)	suffix="SQLC";;
		CRTSQLRPGI)	suffix="SQLRPGLE";;
		CRTSRVPGM)	suffix="BND";;
		*)			echo "*** Unknown command type in src_suffix_for_cmd: $command" >&2;;
	esac

	echo -n "$suffix"
}

# Returns the compile command to be used for a given source code file suffix for stand-alone
# source files that aren't created by a .BLDOPT file.  e.g., .CLLE -> CRTBNDCL, .PF -> CRTPF.
# $1 = the standard source file suffix for a given source file (.RPGLE, .CLE, etc.)
# $2 = 0: return compile command for standalone source files
#      1: return compile command usually used for source files handled by a BLDOPT file
# Returns: the creation command used to build that source file.
creation_command_for_suffix() {
	local suffix=$1
	local useBLDOPT=$2
	local command=
	
	if [ $useBLDOPT -eq 0 ]; then
		case $suffix in
			BND)		command="CRTSRVPGM";;
			CLLE)		command="CRTBNDCL";;
			CMD)		command="CRTCMD";;
			C)			command="CRTBNDC";;
			DSPF)		command="CRTDSPF";;
			LF)			command="CRTLF";;
			MENU)		command="CRTMNU";;
			PF)			command="CRTPF";;
			PNLGRP)		command="CRTPNLGRP";;
			PRTF)		command="CRTPRTF";;
			RPGLE)		command="CRTBNDRPG";;
			SQLC)		command="CRTSQLCI";;
			SQLRPGLE)	command="CRTSQLRPGI";;
			*)			echo "*** Unknown file suffix in creation_command_for_suffix: $suffix" >&2;;
		esac
	elif [ $useBLDOPT -eq 1 ]; then
		case $suffix in
			BND)		command="CRTSRVPGM";;
			CLLE)		command="CRTCLMOD";;
			CMD)		command="CRTCMD";;
			C)			command="CRTCMOD";;
			DSPF)		command="CRTDSPF";;
			LF)			command="CRTLF";;
			MENU)		command="CRTMNU";;
			PF)			command="CRTPF";;
			PNLGRP)		command="CRTPNLGRP";;
			PRTF)		command="CRTPRTF";;
			RPGLE)		command="CRTRPGMOD";;
			SQLC)		command="CRTSQLCI";;
			SQLRPGLE)	command="CRTSQLRPGI";;
			*)			echo "*** Unknown file suffix in creation_command_for_suffix: $suffix" >&2;;
		esac
	fi
	
	echo -n "$command"
}

# The `process_parms` function removes any compile parameters that match our defaults for that object type and
# then outputs the remainder to stdout.
# $1 = object name
# $2 = compile parameters
# $3 = an array containing all our default parameters for that object type
process_parms() {
	local object=$1
	shift
	local parms=$1
	shift
	local defaults=("$@")
	
#	parmsSave=$parms
	parms=" $parms "

	for parm in "${defaults[@]}"; do
#		echo "parms=$parms" >&2
#		echo "parm =$parm" >&2
		parms=${parms/ $parm / }
	done
	
	parms=$(trim $parms)
	
#	echo $object >&2
#	echo "**Original parms: $object: $parmsSave" >&2
#	echo "**     New parms: $object: $parms" >&2

	echo -n "$parms"
}

cleanup_cmd_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If CMD() value equals the object name, remove the parameter.
	parms=${parms/ CMD($object) / }
	
	# If PGM() value equals the object name, remove the parameter.
	parms=${parms/ PGM($object) / }
	
	# If HLPPNLGRP() value equals the object name, remove the parameter.
	parms=${parms/ HLPPNLGRP($object) / }
	
	# If HLPID() value equals the object name, remove the parameter.
	parms=${parms/ HLPID($object) / }

	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_dspf_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If FILE() value equals the object name, remove the parameter.
	parms=${parms/ FILE($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_module_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If MODULE() value equals the object name, remove the parameter.
	parms=${parms/ MODULE($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_pnlgrp_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If PNLGRP() value equals the object name, remove the parameter.
	parms=${parms/ PNLGRP($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_prtf_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If FILE() value equals the object name, remove the parameter.
	parms=${parms/ FILE($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_sqli_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If OBJ() value equals the object name, remove the parameter.
	parms=${parms/ OBJ($object) / }
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_pgm_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If PGM() value equals the object name, remove the parameter.
	parms=${parms/ PGM($object) / }
	
	# Remove MODULE() and BNDSRVPGM() parameters, as they've already been harvested in get_object_deps().
	if [[ "$parms" =~ (MODULE\([^\)]*\)) ]]; then
		parms=${parms/ ${BASH_REMATCH[1]} / }
	fi
	if [[ "$parms" =~ (BNDSRVPGM\([^\)]*\)) ]]; then
		parms=${parms/ ${BASH_REMATCH[1]} / }
	fi
	
	parms=$(trim $parms)
	echo -n "$parms"
}

cleanup_srvpgm_parms() {
	local object=$1
	local parms=$2
	parms=" $parms "
	
	# If SRVPGM() value equals the object name, remove the parameter.
	parms=${parms/ SRVPGM($object) / }
	
	# Remove MODULE() and BNDSRVPGM() parameters, as they've already been harvested in get_object_deps().
	if [[ "$parms" =~ (MODULE\([^\)]*\)) ]]; then
		parms=${parms/ ${BASH_REMATCH[1]} / }
	fi
	if [[ "$parms" =~ (BNDSRVPGM\([^\)]*\)) ]]; then
		parms=${parms/ ${BASH_REMATCH[1]} / }
	fi
	
	parms=$(trim $parms)
	echo -n "$parms"
}

# Gather object dependencies by extracting them from compile parameters
# $1 = base object name, less a file suffix
# $2 = the compile command used to build the object
# $3 = compile parameters from BLDOPT file
get_object_deps() {
	local object=$1
	local command=$2
	local parms=$3
	local deps=
	local output=
	
	case "$command" in
		CRTBNDCL)
			# BNDCL doesn't have any object dependencies.
			;;
		CRTCLMOD)
			# CLMOD doesn't have any object dependencies.
			;;
		CRTCMD)
			# No object dependencies? If a CPP changes, we don't want to recompile the command object.
			;;
		CRTCMOD|CRTBNDC)
			# Is there any way to get a definitive list of files used in C?
			;;
		CRTDSPF)
			# Scan through source and look for REF() and MSGCON() and add them as object dependencies. Any other keywords?
			if [[ -f ${object}.DSPF ]]; then
				deps=$(sed -n -e 's/.*REF(\([^)]*\).*/\1/p' ${object}.DSPF | sed -e '/\// s/.*\///')
				output=$(add_suffix "$deps" FILE)
				deps=$(sed -n -e 's/.*MSGCON(.* \(.*\)).*/\1/p' ${object}.DSPF | sed -e '/\// s/.*\///' | sort -u | xargs)
				deps=$(add_suffix "$deps" MSGF)
				output="$output $deps"
			fi
			;;
		CRTLF)
			# PFILE or JFILE values
			if [[ -f ${object}.LF ]]; then
				deps=$(sed -n -e 's/.*PFILE(\([^)]*\).*/\1/p' -e 's/.*JFILE(\([^)]*\).*/\1/p' ${object}.LF | xargs -n 1 | sort -u | xargs)
				output=$(add_suffix "$deps" FILE)
			fi
			;;
		CRTMNU)
			# Any object dependencies for a MENU object?
			;;
		CRTPF)
			# Scan through source and look for REF() and add those items as object dependencies.
			if [[ -f ${object}.PF ]]; then
				deps=$(sed -n -e 's/.*REF(\([^)]*\).*/\1/p' ${object}.PF | sed -e '/\// s/.*\///')
				output=$(add_suffix "$deps" FILE)
			fi
			;;
		CRTPNLGRP)
			# No object dependencies on panel groups
			;;
		CRTPRTF)
			# Scan through source and look for REF() and MSGCON() and add them as object dependencies. Any other keywords?
			if [[ -f ${object}.PRTF ]]; then
				deps=$(sed -n -e 's/.*REF(\([^)]*\).*/\1/p' ${object}.PRTF | sed -e '/\// s/.*\///')
				output=$(add_suffix "$deps" FILE)
				deps=$(sed -n -e 's/.*MSGCON(.* \(.*\)).*/\1/p' ${object}.PRTF | sed -e '/\// s/.*\///' | sort -u | xargs)
				deps=$(add_suffix "$deps" MSGF)
				output="$output $deps"
			fi
			;;
		CRTRPGMOD|CRTBNDRPG)
			# Scan through source, look for files (externally-described data structures, too), and add them as object dependencies.
			if [[ -f ${object}.RPGLE ]]; then
				deps=$(sed -n -r -e 's/^.{5}[Ff](.{10}).{19}(DISK|WORKSTN|PRINTER).*/\1/I p' -e 's/^.{5}[Dd].*EXTNAME\(([^\)]*).*/\1/I p' ${object}.RPGLE | sort -u | xargs | tr "[:lower:]" "[:upper:]")
				output=$(add_suffix "$deps" FILE)
			fi
			;;
		CRTSQLCI)
			# Is there any way to extract files out of SQLC code?
			;;
		CRTSQLRPGI)
			# Scan through source, look for files (externally-described data structures, too), and add them as object dependencies.
			if [[ -f ${object}.SQLRPGLE ]]; then
				deps=$(sed -n -r -e 's/^.{5}[Ff](.{10}).{19}(DISK|WORKSTN|PRINTER).*/\1/I p' -e 's/^.{5}[Dd].*EXTNAME\(([^\)]*).*/\1/I p' ${object}.SQLRPGLE | sort -u | xargs | tr "[:lower:]" "[:upper:]")
				output=$(add_suffix "$deps" FILE)
			fi
			# Try to detect files accessed by SQL?
			;;
		CRTPGM)			
			# Modules bound into the program
			if [[ $parms =~ MODULE\(([^\)]*)\) ]]; then
				deps="${BASH_REMATCH[1]}"
				output=$(add_suffix "$deps" MODULE)
			fi
			# Service programs linked to this program.
			if [[ $parms =~ BNDSRVPGM\(([^\)]*)\) ]] && [[ ${BASH_REMATCH[1]} != '*NONE' ]]; then
				deps="${BASH_REMATCH[1]}"
				deps=$(add_suffix "$deps" SRVPGM)
				output="$output $deps"
			fi
			;;
		CRTSRVPGM)
			# Modules bound into the service program
			if [[ $parms =~ MODULE\(([^\)]*)\) ]]; then
				deps="${BASH_REMATCH[1]}"
				output=$(add_suffix "$deps" MODULE)
			fi
			# Other service programs linked to this service program.
			if [[ $parms =~ BNDSRVPGM\(([^\)]*)\) ]] && [[ ${BASH_REMATCH[1]} != '*NONE' ]]; then
				deps="${BASH_REMATCH[1]}"
				deps=$(add_suffix "$deps" SRVPGM)
				output="$output $deps"
			fi
			;;
		*)	echo "*** Unknown command $command found for object $object in get_object_deps" >&2
			;;
		esac
		
		echo -n "$(trim $output)"
}

# Gather source dependencies by extracting them from compile parameters
# Note: Header or include files are gathered at compile time, so don't include those here.
get_source_deps() {
	local object=$1
	local command=$2
	local parms=$3
	local deps=
	local output=
	
	case "$command" in
		CRTBNDC|CRTBNDCL|CRTBNDRPG|CRTCLMOD|CRTCMD|CRTCMOD|CRTDSPF|CRTLF|CRTMNU|CRTPF|CRTPNLGRP|CRTPRTF|CRTRPGMOD|CRTSQLCI|CRTSQLRPGI)
			if [[ "$parms" =~ SRCMBR\(([^\)]*)\) ]]; then
				deps=${BASH_REMATCH[1]}
			else
				deps=$object
			fi
			;;
		CRTSRVPGM)
			if [[ -f ${object}.BND ]]; then
				deps=${object}
			fi
			;;
		CRTPGM)
			# No source dependencies for programs.
			;;
		*)
			echo "*** Unknown command $command found for object $object in get_source_deps" >&2
			;;
	esac
	
	local suffix=$(src_suffix_for_cmd "$command")
	output=$(add_suffix "$deps" $suffix)
	
	echo -n "$output"
}

# Prints out to stdout compile parameters in makefile variable format for one object (e.g., TGTRLS = V7R1M0)
# $1 = object name, including suffix ("JSB100.PGM")
# $2 = compile parameters
print_parms() {
	local fullObject=$1
	local parms=$2
	re='^([^\)]*\))'
	
	while [[ "${parms}" =~ ${re} ]]; do
		parm="${BASH_REMATCH[1]}"
		parms=${parms:${#BASH_REMATCH[1]}}
		parms=${parms# }
		#echo "parm: |$parm|"
		
		# Split apart 'ABC(XYZ)' into 'ABC' and 'XYZ'
		if [[ $parm =~ ^([^\(]*)\(([^\)]*)\) ]]; then
			echo "$fullObject: private ${BASH_REMATCH[1]} = ${BASH_REMATCH[2]}"
		fi
	done
}

# Prints a summary report (redirected to stderr)
print_summary() {
	(( totalCount = 0 ))
	echo; echo
	echo "*** EXPORT COMPLETE! ***"
	echo
	echo "Objects exported:"
	echo
	
	for logFile in $metadataDir/*.log; do
		(( count=$(wc -l <$logFile) ))
		(( totalCount += count ))
		printf "\t$(basename ${logFile%.*}):\t%u\n" $count
	done
	
	echo
	echo "Total objects exported: $totalCount"
	echo "Output file: ${metadataDir}/$outputFile"
}

# Logs object to the metadata log file for this object type, as a record of the object existing.
# $1 = object name, with proper suffix (e.g., TEST.PGM)
# $2 = the compile command used to build the object
log_object() {
	local object=$1
	local command=$2
	local objType=${object##*.}
	
	# For files, subdivide them by type (PF, LF, DSPF, etc.) because ultimately compilation order will matter.
	# (Or will Make always figure it out regardless?)
	if [[ "$objType" == FILE ]]; then
		objType=$(src_suffix_for_cmd $command)
	fi
	
	echo "${object}" >> "$metadataDir/${objType}.log"
}

# Main processing for source files
process_standalone_source_file() {
	local base=$(basename "$file")
	local filename="${base%.*}"
	local fileType="${base##*.}"
		
	local commandSolo=$(creation_command_for_suffix "$fileType" 0)
	local commandBldopt=$(creation_command_for_suffix "$fileType" 1)
	
	# If file has a BLDOPT file with the same name that contains a creation command for our type,
	# then do nothing. Things will get handled by the BLDOPT processor.  (This is a quick & dirty
	# educated guess that the source file is compiled by a BLDOPT command.)
	if [[ -f ${filename}.BLDOPT ]]; then
		sed -e :a -e '/+ *$/N; s/ *+ *\n */ /; ta' -e 's/\/\*.*\*\///g' ${filename}.BLDOPT | grep -i -e $commandSolo -e $commandBldopt > /dev/null
		
		if [ $? -eq 0 ]; then
			return 0
		fi
	fi
	
	# There shouldn't be any binder source without a corresponding BLDOPT file.
	if [[ $fileType == "BND" ]]; then
		echo "*** Binder source $filename.$fileType found without a matching BLDOPT!" >&2
	fi
	
	# This is kind of a hack to get obj_suffix_for_cmd() working for non-BLDOPT files.  If a
	# standalone SQLxyz source file is encountered, set a variable to trick obj_suffix_for_cmd()
	# into treating it as a CRTSQLxyzI *PGM object.
	local parms="OBJTYPE(*PGM)"
	
	# If we got this far, the source file likely isn't created by commands in a BLDOPT file, so create a makefile
	# definition for it now.
	local sourceDeps=$(get_source_deps $filename $commandSolo "")
	local objectDeps=$(get_object_deps $filename $commandSolo "")
	local fullObject="$filename.$(obj_suffix_for_cmd $commandSolo)"
	
	# Blank line before each object's entries
	echo
	
	# Add a comment showing object metadata for debug purposes
	echo "# $fullObject -- $commandSolo"
	
	# Write object: sourcedeps objectdeps		
	local output="$fullObject: $sourceDeps"
	output="${output% } $objectDeps"
	output="${output% }"
	echo "$output"
	
	# Write object to metadata log file
	log_object $fullObject $commandSolo
}

# Main processing for the contents of a .BLDOPT file.
#
# Assume that bldopt filename is the same name as all &ZN and &ZE substitution variables.  If this turns out to not
# be the case, remove the sed -e below that inserts $base: at the beginning of the line, and add a function that determines
# object name for each object type based on its object parameter (CMD() for commands, MODULE() for modules, etc.).
process_bldopt() {
	local base=$(basename $file .BLDOPT)

	sed -e 's/\/\*.*\*\///g' -e 's/ *$//' -e :a -e '/+ *$/N; s/ *+ *\n */ /; ta' -e 's/\/\*.*\*\///g' -e 's/^ *//' -e '/^$/d' -e 's/ *) */) /g' -e 's/^/'$base': /' \
        -e 's/&O\/\|&L\///g' -e 's/&ZE\|&ZN/'$base'/g' -e 's/SRCMBR('$base') *//I' -e 's/\*LIBL\///I g' -e 's/ SRCFILE([^)]*) */ /I' \
		-e 's/(  */(/g' -e 's/  *)/)/g' \
		-e 's/REPLACE(\*YES) *//I' -e 's/DBGVIEW([^)]*) *//I' -e 's/OUTPUT(\*PRINT) *//I' -e 's/DETAIL([^)]*) *//I' \
		-e 's/'$DFT_AUT' *//I' -e 's/'$DFT_TGTRLS' *//I' -e 's/'$DFT_USRPRF' *//I' \
		-e 's/\(OPTION([^)]*\)\*GEN *\([^)]*)\)/\1\2/I' -e 's/ *[^ ]\+( *)//Ig' \
	$file | \
	{
		while IFS='' read -r line || [[ -n "$line" ]]; do
			local object=$(trim ${line/:*/})
			local temp=$(trim ${line/${object}:/})
			local command=$(trim ${temp/ */})
			local parms=$(trim ${temp/$command/})
			local fullObject="$object.$(obj_suffix_for_cmd $command)"
			
			# Remove parameters that match our defaults.
			case "$command" in
			CRTBNDCL)	parms=$(process_parms $object "$parms" "${BNDCL_DFT[@]}")
						;;
			CRTCLMOD)	parms=$(process_parms $object "$parms" "${CLMOD_DFT[@]}")
						;;
			CRTCMD)		parms=$(process_parms $object "$parms" "${CMD_DFT[@]}")
						;;
			CRTCMOD)	parms=$(process_parms $object "$parms" "${CMOD_DFT[@]}")
						;;
			CRTDSPF)	parms=$(process_parms $object "$parms" "${DSPF_DFT[@]}")
						;;
			CRTPGM)		parms=$(process_parms $object "$parms" "${PGM_DFT[@]}")
						;;
			CRTPNLGRP)	parms=$(process_parms $object "$parms" "${PNLGRP_DFT[@]}")
						;;
			CRTPRTF)	;; # Nothing to do
			CRTRPGMOD)	parms=$(process_parms $object "$parms" "${RPGMOD_DFT[@]}")
						;;
			CRTSQLCI)	parms=$(process_parms $object "$parms" "${SQLCI_DFT[@]}")
						;;
			CRTSQLRPGI)	parms=$(process_parms $object "$parms" "${SQLRPGI_DFT[@]}")
						;;
			CRTSRVPGM)	parms=$(process_parms $object "$parms" "${SRVPGM_DFT[@]}")
						;;
			*)			echo "*** Unknown command $command found for object $object" >&2
						;;
			esac
			
#		echo "$object: $command $parms"
			
			# Gather object dependencies by extracting from various parameters
			objectDeps=$(get_object_deps $object $command "$parms")
					
			# Extra clean-up
			case "$command" in
			CRTCMD)		parms=$(cleanup_cmd_parms $object "$parms")
						;;
			CRTCMOD	| CRTRPGMOD | CRTCLMOD) 
						parms=$(cleanup_module_parms $object "$parms")
						;;
			CRTDSPF)	parms=$(cleanup_dspf_parms $object "$parms")
						;;
			CRTPNLGRP)	parms=$(cleanup_pnlgrp_parms $object "$parms")
						;;
			CRTPRTF)	parms=$(cleanup_prtf_parms $object "$parms")
						;;
			CRTSQLRPGI | CRTSQLCI)
						parms=$(cleanup_sqli_parms $object "$parms")
						;;
			CRTBNDRPG | CRTBNDCL | CRTPGM)
						parms=$(cleanup_pgm_parms $object "$parms")
						;;
			CRTSRVPGM)	parms=$(cleanup_srvpgm_parms $object "$parms")
						;;
			esac
			
			
			# Get source dependencies for source-based objects (srvpgms can use binder source) (also peer inside RPGs?)
			local sourceDeps=$(get_source_deps $object $command "$parms")
			
			# Blank line before each object's entries
			echo
			
			# For debugging
#			echo "read line: ${line}"
			
			# Add a comment showing object metadata for debug purposes
			echo "# $fullObject -- $command"
			
			## Output custom compile parameters in makefile format
			print_parms $fullObject "$parms"
			
			# Write object: sourcedeps objectdeps		
			local output="$fullObject: $sourceDeps"
			output="${output% } $objectDeps"
			output="${output% }"
			
#			if [[ ${#output} -ge 110 ]]; then
#				echo "$output" | fold -s -w 100 | sed -e '$ ! s/$/\\/'
#			else
				echo "$output"
#			fi

			# Write object to metadata log file
			log_object $fullObject $command
		done
	}
}

############################
# Beginning of main script #
############################

# Clear/create metadata subdirectory for logging imported objects.
if [ ! -d "$metadataDir" ]; then
	mkdir "$metadataDir"
fi
[ "$(ls -A $metadataDir)" ] && rm -r $metadataDir/*
echo "This directory contains info about the items exported into the parent directory." > "$metadataDir/Readme.txt"

files=( "*.*" )
# echo ${files[@]}
for file in $files; do
	sourceType=${file##*.}
	
#	echo "(Processing $file)"

	if [[ $sourceType == "RPGLEINC" || $sourceType == "H" ]]; then
		continue
	fi
	
	if [[ $sourceType == "BLDOPT" ]]; then
		process_bldopt >> $metadataDir/$outputFile
	else
		process_standalone_source_file >> $metadataDir/$outputFile
	fi
done

print_summary >&2
